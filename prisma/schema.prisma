generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String          @id
  name            String?
  email           String?         @unique(map: "user_email_unique")
  emailVerified   DateTime?       @db.Timestamp(6)
  image           String?
  socialAccounts  SocialAccount[]
  subscriptionPlan Subscription?    
  @@map("user")
}

model SocialAccount {
  id                  String                   @id @default(uuid())
  socialType         SocialType
  username            String
  profilePictureUrl  String?
  status              SocialConnectionStatus
  accountId          String                   @unique  
  accessToken        String?
  tokenExpiresAt     DateTime?                @db.Timestamp(6)
  createdAt          DateTime?                @default(now()) @db.Timestamp(6)
  updatedAt          DateTime?                @default(now()) @db.Timestamp(6)
  userId             String
  automations        Automation[]
  user               User                     @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "social_accounts_user_id_user_id_fk")
  chatbot            Chatbot?
  @@map("social_accounts")
} 


model Chatbot  {
  id              String     @id @default(cuid())
  socialAccountId String      @unique
  name            String
  context         String?
  responseTone    String    
  responseTemplate String    
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt
  socialAccount   SocialAccount @relation(fields: [socialAccountId], references: [accountId], onDelete: Cascade)
}


model Automation {
  id           String        @id @default(uuid())
  name         String
  isActive     Boolean       @default(true)
  accountId    String
  targetPosts  String[]
  createdAt    DateTime?     @default(now()) @db.Timestamp(6)
  updatedAt    DateTime?     @default(now()) @db.Timestamp(6)
  account      SocialAccount @relation(fields: [accountId], references: [id], onDelete: Cascade)
  actions      Action[]
  triggers     Trigger?      
}

model Trigger {
  id            String       @id @default(uuid())
  type          TriggerType
  keyword       String
  automationId  String       @unique
  automation    Automation   @relation(fields: [automationId], references: [id], onDelete: Cascade)

}

model Action {
  id            String      @id @default(uuid())
  type          ActionType
  content       String
  automationId  String
  automation    Automation  @relation(fields: [automationId], references: [id], onDelete: Cascade)

  @@map("actions")
}

model SubscriptionPlan {
  id          String   @id @default(cuid())
  plan        SubscriptionPlanType @unique
  price       Float     
  creditLimit Int       
  features    Json      
  duration    Int       
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  subscriptions Subscription?
}

model Subscription {
  id              String           @id @default(cuid())
  userId          String           @unique
  planId          String           @unique
  startDate       DateTime
  endDate         DateTime
  status          SubscriptionStatus
  creditsUsed     Int              @default(0)
  renewsAt        DateTime?         
  cancelledAt     DateTime?         
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan            SubscriptionPlan @relation(fields: [planId], references: [id], onDelete: Cascade)
}



enum SocialType {
  INSTAGRAM
  TWITTER
}

enum SocialConnectionStatus {
  CONNECTED
  DISCONNECTED
}

enum TriggerType {
  COMMENT
  MESSAGE
}

enum ActionType {
  COMMENT_REPLY
  MESSAGE_REPLY
}

enum SubscriptionStatus {
  ACTIVE
  INACTIVE
  CANCELLED
}

enum SubscriptionPlanType {
  FREE
  PREMIUM
  PRO
}
